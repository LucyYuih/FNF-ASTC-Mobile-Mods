import funkin.play.stage.Stage;
import funkin.play.PlayState;
import funkin.util.MathUtil;
import flixel.FlxG;
import funkin.graphics.shaders.AdjustColorShader;
import flixel.tweens.FlxEase;
import flixel.FlxSprite;
import funkin.Conductor;
import funkin.audio.FunkinSound;
import funkin.play.stage.StageProp;
import flixel.tweens.FlxTween;
import funkin.graphics.adobeanimate.FlxAtlasSprite;
import funkin.modding.base.ScriptedFlxAtlasSprite;
import funkin.play.cutscene.CutsceneType;
import flixel.util.FlxTimer;
import flixel.util.FlxTimerManager;

class TheShiftDarkErectStage extends Stage {
	var cameras = [
		{
			enabled: false,
			interval: 4,
			offset: 0,
			intensity: 0.01
		},
		{
			enabled: false,
			interval: 4,
			offset: 0,
			intensity: 0.01
		}
	];
	var dih:Int = 0;
	var shaderBrightness:Int = -80;
	var hudZoom;
	var colorShader:AdjustColorShader;
	var sadTime:Bool;
	var sadSprite:FlxSprite;

	var cutsceneConductor:Conductor;
	var characterShader:AdjustColorShader;
	var cutsceneOutcome = 0;

	var cameras = [
		{
			enabled: false,
			interval: 4,
			offset: 0,
			intensity: 0.01
		},
		{
			enabled: false,
			interval: 4,
			offset: 0,
			intensity: 0.01
		}
	];
	var dih:Int = 0;
	var shaderBrightness:Int = -80;
	var hudZoom;
	var colorShader:AdjustColorShader;
	var sadTime:Bool;
	var sadSprite:FlxSprite;
	var cutsceneConductor:Conductor;
	var characterShader:AdjustColorShader;
	var canDance = true;
	var cutsceneOutcome = 0;

	var hasPlayedSkyCutscene:Bool = false;

	public function new() {
		super('theShiftDarkErect');
		hasPlayedSkyCutscene = false;
	}

	function onCreate(event:ScriptEvent) {
		super.onCreate(event);
		hasPlayedSkyCutscene = false;
		hudZoom = PlayState.instance.defaultHUDCameraZoom;
		shaderBrightness = -80;
		sadTime = false;

		sadSprite = new FlxSprite(-500, -500).loadGraphic(Paths.image('shift/erect/purpleSadnessShader'));
		sadSprite.updateHitbox();
		sadSprite.scale.set(3, 2);
		sadSprite.zIndex = 600;
		sadSprite.alpha = 0;
		sadSprite.blend = 9;
		PlayState.instance.currentStage.add(sadSprite);
		PlayState.instance.currentStage.refresh();
	}

	function buildStage() {
		super.buildStage();

		getNamedProp('blueGradient').blend = 0;
	}

	function onUpdate(elapsed) {
		super.onUpdate(elapsed);

		if (PlayState.instance.currentStage.getGirlfriend().isAnimationFinished() && canDance) {
			PlayState.instance.currentStage.getGirlfriend().dance(true);
		}
		colorShader = new AdjustColorShader();
		colorShader.hue = dih;
		colorShader.saturation = -46;
		colorShader.contrast = 5;
		colorShader.brightness = shaderBrightness;
		var backGround:FlxSprite = getNamedProp('pinkWorld');
		backGround.shader = colorShader;

		dih = 1 + Math.sin((Conductor.instance.songPosition / 1000) * 1) * 100;

		if (sadTime == false && PlayState.instance.currentVariation == 'erect') {
			shaderBrightness += 10 * (FlxG.elapsed * 3);
			FlxTween.tween(sadSprite, {alpha: 0}, 10);
		}
		if (shaderBrightness > -80 && sadTime == false) {
			shaderBrightness = -80;
		}
		if (sadTime == true && PlayState.instance.currentVariation == 'erect') {
			shaderBrightness -= 10 * FlxG.elapsed;
			FlxTween.tween(sadSprite, {alpha: 1}, 10);
		}
		if (shaderBrightness < -160 && sadTime == true) {
			shaderBrightness = -160;
		}

		trace('shaderBrightness' + shaderBrightness);

		/* PlayState.instance.cameraZoomRate = 0;
			var index = 0;
			for (camera in cameras) {
				if (index == 0) {
					PlayState.instance.currentCameraZoom =  MathUtil.coolLerp(PlayState.instance.currentCameraZoom, 0.7, 0.1);
					PlayState.instance.camGame.zoom =  PlayState.instance.currentCameraZoom;
				} else if (index == 1) {
					if (hudZoom != null) {
						PlayState.instance.camHUD.zoom = hudZoom;
						hudZoom = MathUtil.coolLerp(hudZoom, PlayState.instance.defaultHUDCameraZoom, 0.1);
					}
				}
				index++;
		}*/
	}

	override function onBeatHit(event) {
		curBeat = event.beat;
		if (PlayState.instance.currentVariation == 'erect') {
			switch (event.beat) {
				// vignette stuff

				case 224:
					sadTime = true;
				case 352:
					sadTime = false;
			}
		}
	}

	override function addCharacter(character:BaseCharacter, charType:CharacterType):Void {
		// Apply the shader automatically to each character as it gets added.
		super.addCharacter(character, charType);
		trace('Applied stage shader to ' + character.characterName);

		characterShader = new AdjustColorShader();

		characterShader.hue = -27;
		characterShader.saturation = 0;
		characterShader.contrast = 8;
		characterShader.brightness = 0;

		character.shader = characterShader;
	}

	function onUpdate(elapsed) {
		super.onUpdate(elapsed);

		if (PlayState.instance.currentStage.getGirlfriend().isAnimationFinished()) {
			PlayState.instance.currentStage.getGirlfriend().dance(true);
		}
		colorShader = new AdjustColorShader();
		colorShader.hue = dih;
		colorShader.saturation = -46;
		colorShader.contrast = 5;
		colorShader.brightness = shaderBrightness;
		var backGround:FlxSprite = getNamedProp('pinkWorld');
		backGround.shader = colorShader;

		dih = 1 + Math.sin((Conductor.instance.songPosition / 1000) * 1) * 100;

		if (PlayState.instance.currentVariation == 'erect') {
	if (!sadTime) {
		shaderBrightness += 10 * (FlxG.elapsed * 3);
		sadSprite.alpha -= FlxG.elapsed / 10; // fade out over 10 seconds
		if (sadSprite.alpha < 0) sadSprite.alpha = 0;
	} else {
		shaderBrightness -= 10 * FlxG.elapsed;
		sadSprite.alpha += FlxG.elapsed / 10; // fade in over 10 seconds
		if (sadSprite.alpha > 1) sadSprite.alpha = 1;
	}
}

// clamp shaderBrightness if needed
if (!sadTime && shaderBrightness > -80) {
	shaderBrightness = -80;
}
		if (shaderBrightness < -160 && sadTime == true) {
			shaderBrightness = -160;
		}

		trace('shaderBrightness' + shaderBrightness);

		/* PlayState.instance.cameraZoomRate = 0;
			var index = 0;
			for (camera in cameras) {
				if (index == 0) {
					PlayState.instance.currentCameraZoom =  MathUtil.coolLerp(PlayState.instance.currentCameraZoom, 0.7, 0.1);
					PlayState.instance.camGame.zoom =  PlayState.instance.currentCameraZoom;
				} else if (index == 1) {
					if (hudZoom != null) {
						PlayState.instance.camHUD.zoom = hudZoom;
						hudZoom = MathUtil.coolLerp(hudZoom, PlayState.instance.defaultHUDCameraZoom, 0.1);
					}
				}
				index++;
		}*/
	}

	override function onBeatHit(event) {
		curBeat = event.beat;
		if (PlayState.instance.currentVariation == 'erect') {
			switch (event.beat) {
				// vignette stuff

				case 224:
					sadTime = true;
				case 352:
					sadTime = false;
			}
		}
	}

	override function addCharacter(character:BaseCharacter, charType:CharacterType):Void {
		// Apply the shader automatically to each character as it gets added.
		super.addCharacter(character, charType);
		trace('Applied stage shader to ' + character.characterName);

		characterShader = new AdjustColorShader();

		characterShader.hue = -27;
		characterShader.saturation = 0;
		characterShader.contrast = 8;
		characterShader.brightness = 0;

		character.shader = characterShader;
	}

	override function onStepHit(event:SongTimeScriptEvent) {
		/* super.onStepHit(event);
			var index = 0;
			for (camera in cameras) {
				if (camera.enabled) {
					if (event.step % camera.interval == camera.offset) {
						if (index == 0) {
							PlayState.instance.currentCameraZoom += camera.intensity;
						} else if (index == 1) {
							hudZoom += camera.intensity;
						}
					}
				}
				index++;
		}*/
	}

	function onNoteHit(event:HitNoteScriptEvent) {
		super.onNoteHit(event);
	}

	function onNoteMiss(event:NoteScriptEvent) {
		super.onNoteMiss(event);
	}

	function onSongEvent(event) {
		super.onSongEvent(event);
		/* switch (event.eventData.eventKind) {
			case "CameraBopEvent":
				if (event.eventData.value.cameraType != "both") {
					var daCamera = cameras[["game", "hud"].indexOf(event.eventData.value.cameraType)];
					daCamera.enabled = event.eventData.value.enabled;
					daCamera.interval = event.eventData.value.interval;
					daCamera.intensity = event.eventData.value.intensity;
					daCamera.offset = event.eventData.value.offset;
				} else {
					for (daCamera in cameras) {
						daCamera.enabled = event.eventData.value.enabled;
						daCamera.interval = event.eventData.value.interval;
						daCamera.intensity = event.eventData.value.intensity;
						daCamera.offset = event.eventData.value.offset;
					}
				}
			case "AddCameraZoom":
				if (event.eventData.value.cameraType != "both") {
					if (event.eventData.value.cameraType == "hud") {
						hudZoom += event.eventData.value.intensity;
					} else {
						PlayState.instance.currentCameraZoom += event.eventData.value.intensity;
						PlayState.instance.camGame.zoom += event.eventData.value.intensity;
					}
				} else {
					hudZoom += event.eventData.value.intensity;
					PlayState.instance.currentCameraZoom += event.eventData.value.intensity;
					PlayState.instance.camGame.zoom += event.eventData.value.intensity;
				}
		}*/
	}

	public override function onSongEnd(event:CountdownScriptEvent) {
		super.onSongEnd(event);
	}

	override function onSongRetry(event) {
		if (PlayState.instance == null || PlayState.instance.currentStage == null)
			return;
		if (PlayState.instance.isMinimalMode)
			return;
		for (i in cameras) {
			i.enabled = false;
		}
		super.onSongRetry(event);
	}

	public override function onCountdownStart(event:CountdownScriptEvent) {
		super.onCountdownStart(event);
		// PlayState.instance.camHUD.visible = false;
		// begin animation cutscene pico yea yea

		if (PlayState.instance.currentSong.id == 'sky'
			&& PlayState.instance.currentVariation == 'pico'
			&& hasPlayedSkyCutscene == false
			&& PlayState.instance.currentStage.getDad().characterId != 'skyyandere') {
			event.cancel();
			skyPicoCutscene();
		} else {
			hasPlayedSkyCutscene = true;
			PlayState.instance.isInCutscene = false;
		}
	}

	function onSongStart(event:ScriptEvent) {
		super.onSongStart(event);
		FlxTween.tween(PlayState.instance.camHUD, {alpha: 1}, 1);
		canDance = false;
	}

	// CUTSCENE!
	function skyPicoCutscene() {
		PlayState.instance.isInCutscene = true;
		// make sure the game knows we in a cutscene, so we cant hit notes type shit

		var picoPos:Array<Float> = [
			PlayState.instance.currentStage.getBoyfriend().cameraFocusPoint.x,
			PlayState.instance.currentStage.getBoyfriend().cameraFocusPoint.y
		];
		var nenePos:Array<Float> = [
			PlayState.instance.currentStage.getGirlfriend().cameraFocusPoint.x,
			PlayState.instance.currentStage.getGirlfriend().cameraFocusPoint.y
		];
		var skyPos:Array<Float> = [
			PlayState.instance.currentStage.getDad().cameraFocusPoint.x,
			PlayState.instance.currentStage.getDad().cameraFocusPoint.y
		];
		// set variables for the character positions so we dont gotta type ALLAT

		picoPlayer = ScriptedFlxAtlasSprite.init('PicoSkySprite', 0, 0);
		skyOpponent = ScriptedFlxAtlasSprite.init('SkyPicoSprite', 0, 0);
		// settin up the texture atlasses

		picoPlayer.setPosition(PlayState.instance.currentStage.getBoyfriend().x, PlayState.instance.currentStage.getBoyfriend().y + -10);
		skyOpponent.setPosition(PlayState.instance.currentStage.getDad().x - 15, PlayState.instance.currentStage.getDad().y + -10);
		// makin sure the texture atlases show up where they supposed 2 b

		picoPlayer.zIndex = PlayState.instance.currentStage.getBoyfriend().zIndex + 1;
		skyOpponent.zIndex = PlayState.instance.currentStage.getDad().zIndex + 1;
		// make sure the texture atlases are on the same layer as tha characters

		PlayState.instance.currentStage.add(picoPlayer);
		PlayState.instance.currentStage.add(skyOpponent);
		// this is what actually ADDS the atlases to the stage ykwim

		PlayState.instance.currentStage.getBoyfriend().visible = false;
		PlayState.instance.currentStage.getDad().visible = false;
		// this makes the player and opponent invisible so the atlases don't overlap

		PlayState.instance.tweenCameraToPosition(skyPos[0] - 100, skyPos[1] + 50, 0, FlxEase.sineInOut);
		PlayState.instance.tweenCameraZoom(1, 0, true, FlxEase.sineInOut);
		// make sure the camera starts where sky is

		picoPlayer.shader = characterShader;
		skyOpponent.shader = characterShader;

		// okay SO FAR shit is working, just in case anything goes wrong, this is the "savepoint" if u will
		var cutsceneDelay = 1.1;

		var cutsceneVariant = 0;
		// an added ending time for the cutscene depending on what outcome u got

		FunkinSound.playOnce(Paths.sound('skyCutscene/skyCutsceneMusic'), 1);
		// have 2 do this to sync up the audio
		PlayState.instance.camCutscene.fade(0xFF000000, 0, false, null, true);
		// okay ur gonna be seeing a LOT of timers, its a really primitive way to do it and im sure an actual coder would know
		// basically the timers represent a wait before something happens, if it says 1, u gonna wait 1 second, if it says 10 ur gonna wait 10 seconds duhhh

		if (FlxG.random.int(1, 1000) == 50) // 1 in 1000 chance
		{
			cutsceneOutcome = 1;
			cutsceneVariant = 2;
		}
		// make sure the cutscene has a random outcome
		new FlxTimer().start(0 + cutsceneDelay, function(tmr) {
			FlxTween.tween(PlayState.instance.camHUD, {alpha: 0}, 0.01);
			PlayState.instance.camCutscene.fade(0xFF000000, 1, true, null, true);

			skyOpponent.scriptCall('pointAnim');

			picoPlayer.scriptCall('inspectAnim');
		});
		new FlxTimer().start(1 + cutsceneDelay, function(tmr) {
			FunkinSound.playOnce(Paths.sound('skyCutscene/skyHuh'), 1);
			PlayState.instance.tweenCameraToPosition(picoPos[0], picoPos[1] + 50, 2, FlxEase.quadInOut);
			PlayState.instance.tweenCameraZoom(0.9, 2, true, FlxEase.quadInOut);
		});
		new FlxTimer().start(2.5 + cutsceneDelay, function(tmr) {
			FunkinSound.playOnce(Paths.sound('skyCutscene/picoPluh'), 0.7);
		});
		new FlxTimer().start(3.8 + cutsceneDelay, function(tmr) {
			FunkinSound.playOnce(Paths.sound('skyCutscene/blinkSfx'), 1);
		});
		new FlxTimer().start(4 + cutsceneDelay, function(tmr) {
			FunkinSound.playOnce(Paths.sound('skyCutscene/blinkSfx'), 1);
		});
		new FlxTimer().start(4.6 + cutsceneDelay, function(tmr) {
			PlayState.instance.tweenCameraToPosition(nenePos[0], nenePos[1] + 125, 0.5, FlxEase.quintOut);
			PlayState.instance.tweenCameraZoom(0.7, 0.5, true, FlxEase.quintOut);
			FunkinSound.playOnce(Paths.sound('skyCutscene/scramblingSfx'), 2);
			FunkinSound.playOnce(Paths.sound('skyCutscene/upPole'), 0.6);
			skyOpponent.scriptCall('scrambleAnim');

			picoPlayer.scriptCall('upPoleAnim');
		});
		new FlxTimer().start(5.95 + cutsceneDelay, function(tmr) {
			if (cutsceneOutcome == 1) {
				picoPlayer.scriptCall('blamAnim');
			}
		});
		new FlxTimer().start(6 + cutsceneDelay, function(tmr) {
			PlayState.instance.tweenCameraZoom(0.5, 1, true, FlxEase.quintOut);
			PlayState.instance.tweenCameraToPosition(skyPos[0], skyPos[1], 1, FlxEase.quintOut);
			if (cutsceneOutcome == 0) {
				FunkinSound.playOnce(Paths.sound('skyCutscene/gunSfx1'), 2);
				FunkinSound.playOnce(Paths.sound('skyCutscene/freddyFazbearNoseSfx'), 1);
				skyOpponent.scriptCall('dodgeAnim');

				picoPlayer.scriptCall('shootAnim');
			} else if (cutsceneOutcome == 1) {
				skyOpponent.scriptCall('deathAnim');
				PlayState.instance.currentStage.getGirlfriend().playAnimation('laughCutscene', true);
				FunkinSound.playOnce(Paths.sound('skyCutscene/BOOM'), 2);
			}
		});
		new FlxTimer().start(6.1 + cutsceneDelay, function(tmr) {
			if (cutsceneOutcome == 1) {
				FunkinSound.playOnce(Paths.sound('niniHaha'), 1);
			}
		});

		new FlxTimer().start(7.73 + cutsceneDelay, function(tmr) {
			if (cutsceneOutcome == 1) {
				PlayState.instance.tweenCameraZoom(0.55, 1, true, FlxEase.expoOut);
				FunkinSound.playOnce(Paths.sound('skyCutscene/skyFallin'), 3);
			}
		});
		new FlxTimer().start(8.7 + cutsceneDelay + cutsceneVariant, function(tmr) {
			hasPlayedSkyCutscene = true;
			picoPlayer.visible = false;
			PlayState.instance.currentStage.getBoyfriend().visible = true;
			if (cutsceneOutcome == 0) {
				skyOpponent.visible = false;
				PlayState.instance.currentStage.getDad().visible = true;
				// make sure the characters come bakc lol
			} else if (cutsceneOutcome == 1) {
				PlayState.instance.currentStage.getDad().visible = false;
				skyOpponent.visible = true;
				skyOpponent.scriptCall('deadAnim');
			}

			// make sure the atlases go away
			PlayState.instance.startCountdown();

			// make sure the atlases go away
		});
	}

	function onNoteHit(event:HitNoteScriptEvent) {
		super.onNoteHit(event);
		if (PlayState.instance.currentStage == null)
			return;
		if (!event.note.noteData.getMustHitNote() && cutsceneOutcome == 1) {
			event.cancelEvent();
			PlayState.instance.vocals.opponentVolume = 0;
		}
	}

	// this makes sky hit NO notes if shes deads
}
